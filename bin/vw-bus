#!/usr/bin/perl

use strict;
use warnings;
use App::VW;
use POSIX 'setsid';
# TODO  - Ask Marc Lehman about excessive CPU usage.
#       - EV and AnyEvent::Impl::Perl eat up a lot of CPU when idle.
use Event; 
use AnyEvent;
use Data::Dump 'pp';

# NEW PLAN
#   vw-bus (management process) (handles sighup,sigstop,sigchld)
#   \
#    +- continuity
#    +- continuity
#    +- continuity
#    +- continuity
#    +- continuity

my $config = App::VW->config;
my $apps   = App::VW->apps;

sub continuity_server {
  my ($app) = @_;
  # XXX - temporary stub
  AnyEvent->condvar->recv;

  # TODO
  # - require vw_harness.pl
  #   + load modules
  #   + load Squatting::On::Continuity
  #   + loop forever
}

sub continuity_daemon {
  my ($app) = @_;
  defined(my $pid = fork)     or die "Can't fork: $!";
  unless ($pid) {
    chdir '/'                 or die "Can't chdir to /: $!";
    open STDIN,  '/dev/null'  or die "Can't read /dev/null: $!";
    open STDOUT, '>/dev/null' or die "Can't write to /dev/null: $!";
    setsid                    or die "Can't start a new session: $!";
    open STDERR, '>&STDOUT'   or die "Can't dup stdout: $!";
    continuity_server($app);
  } else {
    select(undef, undef, undef, 0.25);
    return ($app, $pid);
  }
}

sub management_daemon {
  my ($config) = @_;
  defined(my $pid = fork)     or die "Can't fork: $!";
  unless ($pid) {
    chdir '/'                 or die "Can't chdir to /: $!";
    open STDIN,  '/dev/null'  or die "Can't read /dev/null: $!";
    open STDOUT, '>/dev/null' or die "Can't write to /dev/null: $!";
    setsid                    or die "Can't start a new session: $!";
    open STDERR, '>&STDOUT'   or die "Can't dup stdout: $!";
    # TODO - start a bunch of continuity_daemons
    # XXX
    AnyEvent->condvar->recv;
  } else {
    select(undef, undef, undef, 0.25);
    return { pid => $pid };
  }
}

### how to construct $pid_file for continuity apps
# my $app_name = lc $app->{app};
# $app_name =~ s/::/_/g;
# my $pid_file = "$app->{dir}/${app_name}_$app->{port}.pid";

sub pid_file {
  my ($pid_file, $pid) = @_;
  open(PID, "> $pid_file") || die($!);
  print PID "$pid\n";
  close(PID);
  return [$pid_file, $pid];
}

# /etc/init.d/vw stop
my $stop = AnyEvent->signal(
  signal => 'STOP',
  cb     => sub {
    warn "kthxbai";
    #for (@$pid_files) {
    #  my $pid = $_->{pid};
    #  kill 15, $pid;
    #  unlink($_->{file});
    #}
  }
);

# /etc/init.d/vw reload
my $reload = AnyEvent->signal(
  signal => 'HUP',
  cb     => sub {
    warn "what would make sense here?";
    warn pp @$pid_files;
  }
);

# when child processes die, I should ____ ?



# main
#_____________________________________________________________________________

my $md = management_daemon($config);
my $pf = pid_file('/var/run/vw.pid', $md->{pid});

