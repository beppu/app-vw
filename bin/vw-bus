#!/usr/bin/perl

use strict;
use warnings;
use App::VW;
use POSIX 'setsid';
# TODO  - Ask Marc Lehman about excessive CPU usage.
#       - EV and AnyEvent::Impl::Perl eat up a lot of CPU when idle.
#       - Event is fine, though.
use Event;
use AnyEvent;
use Time::HiRes;

# FUNCTION STRUCTURE
# 
#   leader_daemon (handles sigint,sighup,(sigchld?))
#   `- continuity_daemon
#   |  `- continuity_server
#   `- continuity_daemon
#   |  `- continuity_server
#   `- continuity_daemon
#   |  `- continuity_server
#   `- continuity_daemon
#      `- continuity_server
#      etc...
#
# * Any function with "daemon" in its name has its own OS process.
# * The leader_daemon watches over the continuity_daemons.
# * Each continuity_daemon runs one continuity_server.
# * The continuity_servers load a script called vw_harness.pl
#   that should be located in the document root of the
#   Squatting+Continuity app.

# AnyEvent->loop    vs.   AnyEvent->condvar->recv
# "any event loop"
# It looks better.
{
  package AnyEvent;
  sub loop { $_[0]->condvar->recv }
}


# TODO - become aware of $ENV{VW_CONFIG}
my $config = App::VW->config;
our $VW_PID_FILE = "/var/run/vw.pid";


sub continuity_server {
  my ($app) = @_;
  chdir($app->{dir});
  my $harness = "$app->{dir}/vw_harness.pl";
  my $pid_file = "$app->{dir}/$app->{port}.pid";
  if (-e $harness) {
    pid_file($pid_file, $app->{port});
    local @ARGV = ($app->{port});
    eval { do $harness; };
    # ...and never return.
    # But if it fails for some reason...
    warn $@; # XXX - use a logging facility instead
    unlink($pid_file);
  }
}

sub continuity_daemon {
  my ($app) = @_;
  defined(my $pid = fork)     or die "Can't fork: $!";
  unless ($pid) {
    continuity_server($app);
  } else {
    return { app => $app, pid => $pid };
  }
}

sub leader_daemon {
  my ($config) = @_;
  defined(my $pid = fork)     or die "Can't fork: $!";
  unless ($pid) {
    chdir '/'                 or die "Can't chdir to /: $!";
    open STDIN,  '/dev/null'  or die "Can't read /dev/null: $!";
    open STDOUT, '>/dev/null' or die "Can't write to /dev/null: $!";
    setsid                    or die "Can't start a new session: $!";
    open STDERR, '>&STDOUT'   or die "Can't dup stdout: $!";

    # list of continuity_daemons
    my @continuities;

    # /etc/init.d/vw stop
    my $stop = AnyEvent->signal(signal => 'INT', cb => sub {
      my @pids = map { $_->{pid} } @continuities;
      kill 15 => @pids;
      sleep 0.25;
      kill 9 => @pids;
      sleep 0.25;
      unlink($VW_PID_FILE);
      exit 0;
    });

    # /etc/init.d/vw reload
    my $reload = AnyEvent->signal(signal => 'HUP', cb => sub {
      # What should it mean to "reload" vw?
    });

    # start a bunch of continuity_daemons
    my @apps = @{ $config->{apps} };
    @continuities = 
      # ^daemonize
      map { continuity_daemon($_) } 
      # ^cluster
      map { 
        my $app = $_;
        map { +{ %$app, port => $app->{port} + ($_ - 1) } } 
          (1 .. $app->{cluster_size});
      } 
      # ^apps
      @apps;

    # loop forever
    AnyEvent->loop;

  } else {
    select(undef, undef, undef, 0.25);
    return { pid => $pid };
  }
}

### how to construct $pid_file for continuity apps
# my $app_name = lc $app->{app};
# $app_name =~ s/::/_/g;
# my $pid_file = "$app->{dir}/${app_name}_$app->{port}.pid";

sub pid_file {
  my ($pid_file, $pid) = @_;
  open(PID, "> $pid_file") || die($!);
  print PID "$pid\n";
  close(PID);
  return [$pid_file, $pid];
}


# main
#_____________________________________________________________________________

my $ld = leader_daemon($config);
my $pf = pid_file($VW_PID_FILE, $ld->{pid});

