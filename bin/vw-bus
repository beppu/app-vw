#!/usr/bin/perl

use strict;
use warnings;
use App::VW;
use POSIX 'setsid';
# TODO  - Ask Marc Lehman about excessive CPU usage.
#       - EV and AnyEvent::Impl::Perl eat up a lot of CPU when idle.
#       - Event is fine, though.
use Event;
use AnyEvent;
use Time::HiRes;



# FUNCTION STRUCTURE
# 
#   leader_daemon (handles sigint,sighup,(sigchld?))
#   `- continuity_daemon
#   |  `- continuity_server
#   `- continuity_daemon
#   |  `- continuity_server
#   `- continuity_daemon
#   |  `- continuity_server
#   `- continuity_daemon
#      `- continuity_server
#      etc...
#
# * Any function with "daemon" has its own OS process.
# * The leader_daemon watches over the continuity_daemons.
# * Each continuity_daemon runs one continuity_server.
# * The continuity_servers load a script called vw_harness.pl
#   that should be located in the document root of the
#   Squatting+Continuity app.



# TODO - become aware of $ENV{VW_CONFIG}
my $config = App::VW->config;

sub continuity_server {
  my ($app) = @_;
  # XXX - temporary stub
  AnyEvent->condvar->recv;

  # TODO
  # - create pid file
  # - require vw_harness.pl
  #   + load modules
  #   + load Squatting::On::Continuity
  #   + loop forever
}

sub continuity_daemon {
  my ($app) = @_;
  defined(my $pid = fork)     or die "Can't fork: $!";
  unless ($pid) {
    chdir '/'                 or die "Can't chdir to /: $!";
    open STDIN,  '/dev/null'  or die "Can't read /dev/null: $!";
    open STDOUT, '>/dev/null' or die "Can't write to /dev/null: $!";
    # *DON'T* start new session => follow the leader
    #setsid                    or die "Can't start a new session: $!";
    open STDERR, '>&STDOUT'   or die "Can't dup stdout: $!";
    continuity_server($app);
  } else {
    select(undef, undef, undef, 0.25);
    return { app => $app, pid => $pid };
  }
}

sub leader_daemon {
  my ($config) = @_;
  defined(my $pid = fork)     or die "Can't fork: $!";
  unless ($pid) {
    chdir '/'                 or die "Can't chdir to /: $!";
    open STDIN,  '/dev/null'  or die "Can't read /dev/null: $!";
    open STDOUT, '>/dev/null' or die "Can't write to /dev/null: $!";
    setsid                    or die "Can't start a new session: $!";
    open STDERR, '>&STDOUT'   or die "Can't dup stdout: $!";

    # daemons
    my @continuities;

    # /etc/init.d/vw stop
    my $stop = AnyEvent->signal(signal => 'INT', cb => sub {
      my @pids = map { $_->{pid} } @continuities;
      kill 15 => @pids;
      sleep 0.25;
      kill 9 => @pids;
      sleep 0.25;
      unlink('/var/run/vw.pid');
      exit 0;
    });

    # /etc/init.d/vw reload
    my $reload = AnyEvent->signal(signal => 'HUP', cb => sub {
      # What should it mean to "reload" vw?
    });

    # start a bunch of continuity_daemons
    my @apps = @{ $config->{apps} };
    @continuities = map { continuity_daemon($_) } @apps;

    # loop forever
    AnyEvent->condvar->recv;

  } else {
    select(undef, undef, undef, 0.25);
    return { pid => $pid };
  }
}

### how to construct $pid_file for continuity apps
# my $app_name = lc $app->{app};
# $app_name =~ s/::/_/g;
# my $pid_file = "$app->{dir}/${app_name}_$app->{port}.pid";

sub pid_file {
  my ($pid_file, $pid) = @_;
  open(PID, "> $pid_file") || die($!);
  print PID "$pid\n";
  close(PID);
  return [$pid_file, $pid];
}


# main
#_____________________________________________________________________________

my $ld = leader_daemon($config);
my $pf = pid_file('/var/run/vw.pid', $ld->{pid});

